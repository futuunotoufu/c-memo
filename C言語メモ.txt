:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: C言語メモ ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::



・「/*」から「*/」まではコメント
・数値などの値を定数という


変数

	オブジェクトともいわれる。

	定義
		その内容によって、値を表現することができる実行環境中の記憶域の領域。


処理系

	ソースプログラムを実行させるために必要なソフトウェアのこと。C言語ではコンパイラ、スクリプト言語ならインタプリタなど。



演算子

	乗除演算子（じょうじょえんざんし）
		*演算子	※乗算。掛け算。
		/演算子	※除算。割り算。
		%演算子	
			※/、%演算子のオペランドに負符号(-)があった場合の演算結果は、処理系に依存する。

	加減演算子
		+演算子
		-演算子

	等価演算子
		==演算子
		!=演算子
			※返り値はint型の1か0

	関係演算子
		<演算子
		>演算子
		<=演算子
		>=演算子
			※返り値はint型の1か0
		

	添字演算子
		n[0]

	条件演算子（３項演算子）
		a ? b : c		aが非0であれば、bを評価した値、そうでなければcを評価した値。

	論理演算子
		&&演算子		短絡評価が行われる
		||演算子		短絡評価が行われる

	複合代入演算子
		+=  -=  *=  /=

	後置増分演算子、後置減分演算子
		a++	a--
			while (no-- > 0)		/* noの評価がされてから、デクリメントが行われる。*/

	前置増分演算子、前置減分演算子
		++a	--a
			printf("%d",++i);		/* iの値をインクリメントした後に表示*/

	ビット単位の論理演算子
		&演算子		オペランドのビット単位の論理積を求める
		|演算子		オペランドのビット単位の論理和を求める
		^演算子		オペランドのビット単位の排他論理和を求める。(一方のみ1であれば1、オペランドが両方同じ値であれば0)
		~演算子		オペランドのビット単位の補数を求める。(すべてのビットを反転した値)

	ビット単位のシフト演算子

		処理系によって論理シフトか算術シフトが行われる。
		プログラムの可搬性が損なわれるので、特別な必要がない限り、負数のシフトは行うべきではない。

			論理シフト
				符号ビットを含めてシフトするため、符号も変わってしまう

			算術シフト
				符号以外をシフトする。シフト前の符号ビットで空きを埋める。
		
		<<演算子
			a << b	aのビットうち右端から数えたbビットを左端にシフトする。右端に空いたビットには0を埋める。要はbビットの0を右端に挿入する。

		>>演算子
			a >> b	aのビットのうち左端から数えたbビットを右端にシフトする。左端に空いたビットは0で埋める。要はbビットの0を左端に挿入する。
				a >>= b　はa = a >> bと同じ

	代入式
		代入式を評価して得られるのは、代入後の左オペランドの型と値である。
			int n;
			n = 2.95;		/*評価で得られるのはint型の2*/

	コンマ演算子
		aとbを順番に評価し、式全体としてはbの評価値を生成。
			i = 3; j = 5;
			x = ++i,++j;	/*i,j共にインクリメントされ、xに代入されるのはjで値は6になる。


	sizeof演算子

		型の大きさをバイト単位で返す。使う時は必ずキャストが必要。変換指定は%u。
		生成する値の型は、size_t型だが、実際は<stddef.h>ヘッダでtypedef宣言によってunsignedの別名として宣言されている。
		よって、size_t型とはunsigned型のことである。

			型の大きさを知りたい場合
				(unsigned)sizeof(char)

			変数や式などの大きさを知りたい場合
				(unsigned)sizeof(a + b)

	メンバアクセス演算子

		.演算子
			a.bは構造体aのメンバbを表す。

		->演算子
			a->bはaが指す構造体のメンバbを表す。


型

	型は、いわゆるクラスであって、型（クラス）で定義された変数はオブジェクト（インスタンス）にあたる。

	オブジェクト型

		算術型

			文字型（汎整数型、基本型）

				単なるchar型が符号付き型なのか、符号無し型なのかは、処理系によってことなる。

				char
				signed char
				unsigned char

			整数型（汎整数型、基本型）

				int型
					整数を扱う型。確実に表現できる値として保証されているのは、-32767から32767まで。
					除算式の場合、オペランドの一方がdouble型だったら、結果が自動的にdouble型に型変換される。
					long intよりintのほうが処理は早くなる。

					整数定数
						5や37などの整数の型をもつもの。

						構文図
							整数定数	　→　	8進定数	　→　整数接尾語　→
								　→	10進定数
								　→	16進定数

						10進定数
							通常の10進数の数値
						8進定数
							先頭に0をつけた8進数の数値。
						16進定数
							先頭に0x(0X)を付けた16進数の数値。

					オーバーフロー
						桁あふれのこと。

						例外処理
							表現可能な値の範囲を超える場合、0による除算などによって数学的に定義できない場合。

						 桁あふれの数値 % (表現可能な値 + 1)
							符号無し整数型の演算。

				符号無し整数型 :unsigned int 
					ビット	:	二進数にそのまま対応させたもの
																変換指定		サフィックス(接尾子)
						short		:unsigned short int		unsigned short 		
						通常		:unsigned int			unsigned			%u			1u,1U
						long		:unsigned long int		unsigned long						1ul,1UL

				符号付き整数型 :signed int ※符号指定しない場合は符号付整数型になる。
					ビット	:	処理系によって異なるが、いずれも最上位ビットが符号ビットとなる。（0が正。1が負）
																			サフィックス(接尾子)
						short		:signed short int		short int		short
						通常		:signed int 			signed		int
						long		:signed long int		signed long		long int	long		1l,1L

	
			列挙型（汎整数型）


			浮動小数点型（基本型）

				内部的には大きさ(指数)と精度(仮数)で表現される。
										変換指定
				float							%f
				double		2倍の精度に由来する。	%f
				long double						%Lf
	
				浮動小数点定数
					3.14のような小数部をもつ定数。

					構文図
						→　整数部　→　.　→　小数部　→　E　→　+ or -　→　指数部　→　浮動小数点接尾語　→

									サフィックス(接尾子)
						float			f,F
						double			ない場合はdoubleとなる
						long double		l,L

				浮動小数点型が受け取る値を正確に表現できない理由

					⑴仮数と指数の表現範囲
						仮数の桁数が精度に相当し、指数の値が大きさに相当する。値が1234567890であっても、大きさが12で精度が
						6桁までの表現だった場合には12345670000となる。
							　　　仮数　　　指数
						1234567890 → 1.23456 × 10(9乗)

					⑵仮数と指数の大きさは実際には2進数である
						大きさ（指数）が12桁で精度（仮数）が6桁であっても、それはあくまで10進数での指令段階の数値で、実際
						には2進数のビット範囲ということになる。

					⑶小数部の2進数表現
						小数部を10進数の値から2進数に変換する場合、2のべき乗の桁で表現される。よって0.5、0.25、0.125、…の
						和にならない値は表現できない。
							2進数		10進数		
							0.1	0.5	2の-1乗
							0.01	0.25	2の-2乗
							0.001	0.125	2の-3乗
							0.0001	0.0625	2の-4乗

	関数型

	不完全型

				
	キャスト

		式の値を指定した型に変換する。
			(型)式	(int)5.7	:5

	typedef宣言

		既存の型に対して別名をあたえる。
			typedef 既存の型名 別名;



分岐

	選択文

		if文

			式を評価して、値が非0であれば文を実行する
				if (no == 0)				/*()の中を制御式という*/
					puts("その数は0です。");
				else if (no > 0)
					puts("その数は正です。");
				else
					puts("その数は負です。");


		switch文

			評価した値と==になるラベルへジャンプする。「case ラベル」のラベルは定数でなければならない。
			break文が無い場合は、そのまま下の行も実行される。
				switch(no % 3){
					case 0 : puts("その数は３で割り切れます。");		break;
					case 1 : puts("その数を３で割った剰余は１です。");	break;
					case 2 : puts("その数を３で割った剰余は２です。");	break;
				}


繰り返し

	do文
		do文を実行し、while文で評価して、非0であればdo文を繰り返し実行する。
			do {
				文
			}while (評価式);

	while文
		評価した値が非0であれば文を実行し、0であれば抜ける。
			while (評価式)
				文;

	for文
		まず式１を実行（評価）する。（通常は変数の初期化や定義）次に式２を評価し、値が非0であれば文を実行した後に式３を評価する。
		式３の評価が終わったら式２へループする。
			for (式１;式2;式3)
				文;


配列

	定義
		要素型・変数名・要素数で宣言する。	[]の中の値を添字という。
			int a[5]

	初期化
		初期化子が与えられていれば、要素数を省略できる。
			int v[] = {1,2,3,4,5};

	※※C言語では配列を単純代入演算子(=)で代入することはできない！なのでfor文などによって要素を一つずつコピーする必要がある。
		×	b = a;
		〇	for(i = 0; i < 5; i++)
				b[i] = a[i];

	要素数を求める式
		(unsigned)(sizeof(a) / sizeof(a[0]))

	多次元配列

		関数の仮引数
			関数の仮引数で多次元配列を受け取る場合、先頭の添字は省略可能。厳密には先頭の添字のみが可変である。
			この実態は、先頭の添え字が実際にはポインタだから。
				void func(int v[][2][3]);
				void func(int (*v)[2][3]);

		構成要素
			配列でない次元まで分割した要素のこと。つまり、その多次元配列の最小要素のこと。すべての構成要素は連続したアドレスで配置される。

		要素数の求めかた
			aの要素数		sizeof(a) / sizeof(a[0])
			a[0]の要素数		sizeof(a[0]) / sizeof(a[0][0])



有効範囲（スコープ）

	ブロック有効範囲

		関数などのブロックの範囲内で、変数の内容が適用される。同じ名前の変数は、より内側で宣言されたものが優先される。

	ファイル有効範囲

		関数の外で宣言された変数は、プログラムの終端まで有効になる。但し、範囲は広いが優先順位は一番低い。

		定義でもある宣言
			実体を作り出す宣言。通常の宣言
				int tensu[5];

		定義ではない、単なる宣言
			関数の外ですでに宣言された変数を、改めて宣言する。省略可能。
				
				extern int tensu[];

			関数原型宣言
		
				main関数の後に関数宣言を配置する場合は、それを知らせる宣言をmain関数の前に置く。定義ではない、単なる宣言にあたる。
					int top(void);

	割り付け記憶期間

		calloc(),maloc(),realloc(),free()などで動的に確保・解放するオブジェクトの記憶期間のこと。

	ヘッダ

		ヘッダでも、include指令によりライブラリ関数の関数原型宣言が行われている。

記憶域期間

	自動記憶域期間

		ブロックが終了した時点で内容が破棄される。初期化子が与えられなければ不定値で初期化される。
			・関数の中で定義された変数	

		register記憶域クラス指定子
			自動記憶域期間が与えられ、変数を主記憶よりも高速なレジスタに格納したほうがよいというヒントを与える。しかし、現在はどの変数をレジスタに割り当てれば
			プログラムが高速化するかをコンパイラが判断できる。アドレス演算子は適用できなくなる。

	静的記憶期間

		プログラムが終了する時に破棄される。プログラム実行開始の準備段階(main関数の前)に生成される。初期化子が与えられなければ0で初期化される。
			・ヘッダで宣言された変数
			・ブロック内で記憶域クラス指定子(static)をつけて宣言された変数

		記憶域クラス指定子(static)

			初期化時に指定することで静的記憶域期間となる。ループであった場合は、毎度初期化がリセットされるわけではなく、前の値を保持する。
			初期化があたえられなければ0で初期化される。

	境界調整
		処理系や環境によって特定の型のオブジェクトを特定のバイトアドレスの倍数（偶数番地/4や/8で割り切れる番地）のアドレスをもつ記憶域境界に割り付ける要求。
		要は、型の記憶域できりのいい単位で記憶域を割り当てることで、そのぶん無駄な領域ができる。char型は境界調整の問題がない。
		構造体の場合、メンバの配置は<stddef.h>のoffsetof()で求めることができる。


		



------------------------------------------------------------ マクロ ------------------------------------------------------------


オブジェクト形式マクロ

	#define a b

		この指令以降のaをbに置換せよという命令。
			#define NUMBER 5

			マクロ名
				NUMBERの部分のこと。変数名と区別して、大文字とする習慣がある。

			マジックナンバー
				5の部分のこと。何を表すための数値なのかが、よくわからない数という意味。

		EOF
			End Of File。負の値(-1)として定義されている。値は処理系によって異なる。


関数形式マクロ

	似たような機能をもつ関数を作りたい時などに利用できる。関数のように引数の受け渡しなどが行われるわけではなく、そのまま式が当てはめられるというイメージなので
	型に応じて計算し、その型で結果を返す。

	#define 関数名(値) 式

		#define sqr(x) ((x) * (x))
		#define alert() (putchar('/a')


	複数式がある場合は、コンマ演算子を活用する

		#define puts_alert(x) {putchar('\a'); puts(x);}	
		これを  		if(n) puts_alert("はい");　	と呼び出すとエラーになる。理由はマクロ側の{}とif文の;が二重の終了になっている。
			↓
		コンマ演算子を活用する
		#define puts_alert(x) (putchar('\a') , puts(x) )


<limits.h>ヘッダ

	INT_MIN	intの最小値
	INT_MAX	intの最大値


------------------------------------------------------------ 列挙体 ------------------------------------------------------------


定義

	宣言
		ヘッダに宣言する。enum animal型という列挙型を宣言するという意味。
		列挙定数はイメージとして、選択肢から１個だけ選択可能なラジオボタンのような感じ。列挙定数は宣言時に指定することができる。

				列挙型タグ	列挙定数0	1	2	  3
			enum	animal		{ Dog, 	Cat, Monkey, Invalid };
						  0		5	   6
			enum	kyushu 		{ Fukuoka, Saga = 5,Nagasaki };
						  0		0
			enum namae		{ Shibata, Washio = 0 };

	関数
		enum animal select(void)
		{
			int tmp;
			do{
				printf("0…犬　1…猫　2…猿　3…終了：");
				scanf("%d",&tmp);
			}while (tmp < Dog || tmp > Invalid);
			return tmp;							/*返却値がint型なので、キャストした(enum animal)tmpで返してもよい
		}

	main関数
		main関数では列挙型の関数を呼び出した値は、なるべく列挙型の変数に格納する。

		enum animal selected;		/*enum animalが型で、selectedが変数名(識別子)*/
		do {
			switch (selected = select()){
				case Dog		:dog();	break;
				case Cat		:cat();	break;
				case Monkey		:monkey();	break;
			}
		}while(selected != Invalid);


	名前空間

		ここでいう名前空間とは、例えばタグ名のenum animalと変数名がenum animal animalで同じ名前になっても識別されるということ。



----------------------------------------------------------- 文字列 -------------------------------------------------------------


文字列

	文字列リテラル

		・""で囲んだ文字列。printfでの文字表示やポインタに文字列を格納する時など、「文字列」以外が文字列リテラルである。
		・文字列リテラルは、変数でないにもかかわらず、記憶域を占有し、プログラム終了まで有効である静的記憶域期間をもつcharの配列。
		・「%」を出力する時は、「%%」と記述する。文字は非負の整数値による文字コードが実体である。
		・同じ内容の文字列リテラルは、１つのものを共有するか、個別に格納して扱うかは処理系による。
	
		【記事より】
			・文字列リテラルは、ソースコードに記述された文字列のこと。（ソースコード中に記述された値のことを”リテラル”と呼ぶ）
			・ソースコード中に記述された文字列リテラルはメモリ上に配置される。
			・文字列リテラルは内部的には先頭アドレスとして扱われる。
				※printf("Hello");の場合、"Hello"の先頭アドレスをprintfに渡している
			・文字列リテラルの変更は禁止されている。

		ナル文字
			文字列リテラルが記憶域に保存されるときに末尾に付加される値が0の文字。(\0)厳密にはすべてのビットが0のバイト。
				for (i = 0; s[i] != '\0'; i++)		/*ナル文字まで繰り返す*/
			※文字列リテラルの場合は、文字列の途中にナル文字があっても問題ない。
			※

		空白類
			空白、改行、タブなどの総称で、空白類をはさんだ文字列は連結される。

		等価演算子や関係演算子による比較
			文字列を文字列リテラルを等価演算子や関係演算子を使って比較することはできない。strcmpなどの関数を使う必要がある。

		添字演算子の利用
			c = "ABC"[1];		/*Bが代入される*/
			c = 2["DEFG" + 1;	/*"DEFG" + 1はEを指す。2["DEFG"+1は("DEFG"+1)[2]と同じなのでGが代入*/


	文字定数

		''で囲んだ文字で単一の文字を表す。int型になる。空文字('')は使えない。

		文字列の初期化
			char str[] = {'A','B','C','\0'};
			char str[] = "ABC";

	文字列

		文字列リテラルと似ているが、文字列はオブジェクトに格納された文字列のこと。
		※文字列はナル文字が文字列の末尾とみなされるので、途中であった場合は、そこが末尾とみなされる。
			char name[128];
			scanf("%s",name);	/*文字列は&をつけない*/

		文字列の長さを調べる
			while ( s[len])
				len ++;
			return len;

		文字列を空にする
			s[0] - '\0';		/*おすすめ*/


	文字列ではない文字の配列

			char str[4] = "ABCD";

		文字列の場合、ナル文字を含めると５文字文の領域が必要だが、ナル文字文の要素数が足りない場合は、文字列ではなく配列とみなされる。




----------------------------------------------------------- ポインタ -------------------------------------------------------------


ポインタとは

	&演算子によって生成された、Type *型の型をもつ値（アドレス）。

		アドレスはバイト単位
			アドレスの増減は、バイト単位である。intが2バイトの場合、先頭アドレス212で212と213を占有する。(処理系によっては211、212の場合もある)

		アドレスの格納
			上記のような値（バイト）をアドレスに格納する内部表現は処理系によって以下の２種類がある。

			リトルエンディアン
				２バイトの型であった場合。下位アドレス(1～4ビット)が低いアドレス(例:212)で、上位アドレス(5～8ビットが高いアドレス(例:213)になる方式。

			ビッグエンディアン
				２バイトの型であった場合。下位アドレス(1～4ビット)が高いアドレス(例:213)で、上位アドレス(5～8ビットが低いアドレス(例:212)になる方式。

		アドレス値を整数に変換する
			アドレス値を整数値に変換する場合において、変換先の型は処理系に依存する。なので、むやみにキャストするのは危険で、もしキャストする場合には、許容範囲
			が広いunsigned long型でするべきである。

		ポインタの比較
			加算はできないが、減算はできる。減算で得られる値はptrdiff_t型で符号付き整数型の別名になる(shot,int,longのどれかは処理系による)。
			関係演算子は同一配列内の要素どうしであれば可能。

	変数

		変数　=  記憶域（メモリ空間）

		性質（それぞれの違い）
			・型
			・記憶期間
			・識別子

	アドレス演算子	(&演算子)		
				≪※あくまで値はアドレス≫

		オブジェクトに&演算子をつけると、そのオブジェクトのアドレスが得られる。
			printf("nのアドレスは: %p\n",&n);


	int * 型（	intへのポインタ型）	
				≪※あくまで型のこと≫

		int型（整数を格納するオブジェクト）のアドレスを格納する箱。&演算子で得たアドレスを代入することでポインタを生成する。
		厳密には、アドレス〇〇番地を先頭に格納されたType型のオブジェクトを指す。
			int *isako;
			isako = &sato;		/*アドレス値を代入する時は「*」がつかない。

		void *型
			どんな型にも代入できる万能なポインタ。整数値の加減算、間接演算子、添字演算子も使えない。


	間接演算子(*演算子)		
				≪※あくまでポインタが指すアドレスのオブジェクトそのもの（値）を指す≫

		ポインタ（アドレス値）が指すオブジェクトのそのもの（値）を指す。*演算子を元のオブジェクトのエイリアス（別名）という。
		また、*演算子を使ってオブジェクトを間接的に操作することを参照外しという。
			int masaki = 179;
			int *hiroko;
			hiroko = &masaki;
			*hiroko = 180						/*hirokoとmasakiは同じオブジェクトを指す*/
			printf("真崎君の身長は：%d\n",masaki);		/*真崎君の身長は：180*/

			void hiroko(int *height){}
			int main(void){
				int masaki = 179;
				hiroko(&masaki);					/*関数にポインタとして渡す時は&演算子をつける*/

		二重に渡す場合
			void swap(int *px, int *py){}
			void sort(int *n1,int *n2){
				if(*n1 > *n2)
					swap(n1,n2);				/*二重にポインタを渡す時は&はいらない*/
			}
			int main(void){
				sort(&na,&nb);

	Type **型
	
		実引数をアドレス（実際はポインタ）で渡す場合、仮引数はType **型になる。
			void swap(char **x,char **y)

	空ポインタ(NULL)

		何も指さない特殊なポインタであるNULLのこと。内部表現は処理系に依存する。
			空ポインタへの初期化は共通
				int *p = 0;	or	int *p = NULL;
			しかし空ポインタになったら全ビット0であるとは限らない
			


	スカラ型

		算術型とポインタ型を合わせてスカラ型と呼ぶ。
			※scalarとは、「数」、「数と同等な性質をもつ量」のこと。

	派生型

		C言語で構造体や配列など、派生して作られたものを派生型と呼ぶ。基本型からの派生（導出）を行えば、新しい派生型を自由に作りだせる。

		配列型
			ある要素型のオブジェクトをもつ集合を連続して記憶域に割り当てる。（配列のこと）

		構造体型
			メンバを宣言された順番に記憶域に割り当てる。（構造体のこと）

		共用体型
			メンバが重なり合って割付られる。

		関数型
			一つの返却値型と、0個以上の仮引数から作られる（関数のこと）

		ポインタ型
			オブジェクトあるいは関数を指す型として作り出される。（ポインタのこと）



配列

	・原則として、配列名は、その配列の先頭要素へのポインタと解釈される。(a == &a[0])つまり値はアドレスになる。
	・ポインタpが配列中の要素eを指すとき
		p + i は、要素eのi個だけ後方の要素を指すポインタとなる
		p - i は、要素のi個だけ前方の要素を指すポインタとなる
			int a[5];
			int *p = a;		/*a[2] == (p + 2)*/

	ポインタ（アドレス値）とエイリアス
		&a[0] == (a + 0) == &p[0] == (p + 0)

	配列の値と*演算子
		a[0] == *(a + 0) == p[0] == *(p + 0)	/*0[a]もOK*/
		※pとaの相違点として、配列は通常、要素数がn個だったらa[0]～a[n-1]までの要素で構成されるが、ポインタの場合はn[0]～n[n]まで有効である。

	関数の仮引数が配列の場合は、実際にはType *型として受け取っている
		
		void ary_set(int v[],...) 
		void ary_set(int v[5], ...) 

		どちらも実際は下のようになる
		void ary_set(int *v,...)

	関数内で作られた配列はstaticが必要
		char *weekstr(int wd){
			static char wstr[][10] = {'0'};

	多次元配列
		仮引数の扱い
			void fill(int (*a)[3], int n)	/*第一仮引数が受け取るのはint (*)[3]型の&x[0]。&xや&x[0][0]ではない。
				/*　中略　*/
			int main(void)
				{
					int x[2][3] = {0};
					fill(x,2)

			int *型			intへのポインタ型		&x[0][0]	構成要素x[0][0]を指す
			int (*)[3]型		int[3]へのポインタ型	&x[0]		要素x[0]を指す
			int (*)[2][3]型		int[2][3]へのポインタ型	&x		配列x全体を指す

		二次元配列の仮引数を疑似的に一次元配列として扱う
			void fill(int *a,int n1,int n2,int v)
				{
					int i,j;
					for (i = 0; i < n1; i++)
						for(j = 0;j < n2; j++)
							a[i * n2 + j] = v; 
			

文字列とポインタ

	配列による文字列

		配列の先頭アドレスから順に文字列が格納される。

			char str[] = "ABC";
		char型の配列で、各要素は'A','B','C','\0'のサイズは4バイトになる。

		代入
			char s[] = "ABC";
			s = "DEF";			/*エラー。配列に対する代入はできないため*/

		配列
			char a[][5] = {"LISP","C","Ada"};		/*格納される文字は連続した配列に順番に入る*/


	ポインタによる文字列

		文字列リテラルで格納された記憶域の先頭アドレスがポインタに代入される。サイズは文字列とポインタのサイズを含めたものになる。

			char *ptr = "123";
			char *ptr = {'1','2','3',\0'};	/*エラー。{}形式の初期化子は、単一の変数には適用できないため*/
		ポインタptrには'1'のアドレスが入り、ポインタptrが文字列リテラル"123"の先頭文字'1'を指すことを、「ポインタptrは"123"を指す」という。

		代入
			char *p = "123";
			p = "456";			/*OK。あくまでポインタのアドレスが変更されるだけ*/
			p = "456" + 1;		/*"56"*/

		配列
			一見配列と変わらないが、格納される文字のアドレスはバラバラになる。これは、文字列をコピーしたい時に記述の仕方に気を付ける必要がある。
			char *p[] = {"PAUL","X","MAC"};			/*サイズは文字列×文字数のポインタ数になる。二次元配列と違って一時配列が可変*/
			printf("p[0][0] = \"%s\"",p[0][0]);		/*p[0][0] = "P"*/

		コピー
			char str[128] = "ABC";		char tmp[128] = "XYZ";
			char *d = str;			char *s = tmp;
			while (*d++ = *s++);

		関数内で作られた文字列リテラルの配列
			文字列リテラルに、静的記憶期間が与えられるためstaticは必要ない
				char *wptr[] = {"Sunday","Monday","Tuesday"};


関数へのポインタ

		void kuku(int calc(int,int))		/*仮引数はint (*calc)(int,int)でもよい*/
			{

		kuku(sum);				/*実引数sumは関数*/

	関数へのポインタの配列

		配列の中身を関数へのポインタとして格納して使う。




----------------------------------------------------------- 構造体 -------------------------------------------------------------


構造体の基本

	型の宣言

		列挙体のようにヘッダで型の宣言をする。

			struct student{
				char	name[64];
				int	height;
				float	weight;
				long	schols;
			};

		型名（クラス名）
			struct studentが型名になる。

		構造体タグ
			構造体に与えられた名前であるstudentの部分のこと。

		変数を同時に宣言する
			struct student{
				int	height;
				float	weight;
			}sanaka,takao;

		ビットフィールド
			ビットを指定した特別なメンバの定義。ビットフィールドは16ビットや32ビットなどの整数型と同じビット数の中にパックとして格納される。
				struct bf{
					unsigned a : 1;
					unsigned b : 5;
					unsigned c : 2;
				} x;


	変数の宣言

			　　型名　　　  変数名
			struct student sanaka

		変数の代入
			sanaka.height = 175;

		初期化
			struct student takao = {"Takao",173,86.2};

		構造体同士の代入
			struct student x,y;
			x = y;			/*配列と違ってまるごとの代入ができる。但し、違う型は×*/


	メンバ

		構造体の内容である１つの項目
			typedef struct {
				double x;		/*メンバ１*/
				double y;		/*メンバ２*/
			}Pint;

		構成メンバ
			これ以上分割できないメンバで、構造体の中の構造体メンバなど。
				typedef struct{
					double x;
					double y;
				} Pint;

				typedef struct}
					Point pt;
					double fuel;
				}Car;
			
				Car c;
				c.pt.x = 5;

		メンバのアドレス
			宣言された順に記憶域上に配置される。


	ポインタ

			struct student{
			char		name[64];
			int		height;
			float		weight;
		};

		void hiroko(struct student *std)
		{
			if((*std).height < 180) (*std).height = 180;		/* (*std)の()は*が演算子であるため必要*/
			if(std->weight > 80) std->weight = 80;			/*エイリアスは(*std).heightでもstd->heightでもよい*/

		int main(void)
		{
			struct  student sanaka = {"Sanaka",175,62.5};
			hiroko(&sanaka);

	配列

		struct student std[5];
		scanf("%s",std[0].name);


	typedef
	
		構造体の型名は長いのでtypedef宣言によって簡潔にするとよい
			typedef struct student{
				char	name[64];
				int	height;
			}Student;

			int main(void)
			{
				Student sanaka = {"Sanaka",175};




------------------------------------------------------------- 関数 -------------------------------------------------------------


関数定義

	返却値型　関数名　仮引数型並び
	int	    max2	(int a,int b)
	{
		if (a > b)
			returna;
		else
			return b;		/*返却値は１個に限られる*/
	}

	値渡し
		実引数が変数そのものではなく、あくまでコピーの値であること。


	配列の実引数
		max_of(eng);		/*配列の変数名だけで、[]はつけない*/

	配列の仮引数
		int max_of(int v[])	/*[]をつける*/

		・関数で配列を仮引数として受け取った場合、変数名などは違っても「仮引数の配列は、実引数の配列そのもの」となる。
		・実引数の値を変えたくない場合は、型の前に「const」を付ける。	const int v[]


値を返さない関数

	返却地を返さない場合は、関数頭部の最初をvoidと宣言する。
		void put_chars(int a,int b)
		{


仮引数を受け取らない関数

	仮引数を受け取らない関数の場合は、仮引数の値をvoidとする。
		int scan_print(void)


再帰的な関数

	ある関数を、その関数定義の中で呼び出している関数。


main関数

	コマンドライン引数
		プログラム起動時に渡される引数。（実際には、プログラム本体の実行開始前に受け渡しが行われる)
		コマンドライン引数を受け取るのは、プログラムがOSなどのホスト環境で実行されている場合。
			int main(int argc,char *argv[])
		第１引数argc
			渡される引数の数。
		第２引数argv
			charへのポインタの配列型で、[0]にはプログラム名が入り、それ以降はプログラム仮引数が入る。末尾要素には空ポインタが格納される。

			　③			②		①		①②③は別領域で、①から順に生成される。
			argv(char **型)	→	[0]	→	argtest1\0	プログラム名
						[1]	→	Sort\0		プログラム仮引数
						[2]	→	BinTree\0
						[3]	→	空ポインタ		番兵として機能する（終了条件の目安)
			①プログラム名とプログラム仮引数の文字列を格納するための領域
			②①の文字列のポインタが格納された配列。
			③①②が完了するとmain関数が呼び出され、argcとargvが渡される。
			


標準ライブラリ関数

	#include <stdio.h>

		scanf
			キーボード(標準ストリーム）から入力された値を受け取る。変数に&がいる。返却値は入力に成功した個数で、エラーの場合はEOF。
				scanf("%d",&no);
				scanf("%s",name);	/*文字列は&をつけない*/
				scanf("%d",p);		/*ポインタも&をつけない。付けたらポインタが指しているアドレスを書き換えることになる*/

		fscanf
			標準ストリームではなく、streamが指すストリームから読み取る。第１引数にFILE *型になる以外はscanfと同じ。つまり、キーボードから入力を受け
			取るのではなく、ファイルから入力を受け取る。
				FILE *fp;
				if((fp = fopen("hw.bat", "r")) == NULL)
					printf("\aファイルをオープンできません。\n");
				else{
					wthile (fscanf(fp,"%s%lf%f",name,&height,&weight) == 3){	/*1個の文字列と2個のdouble型実数を各変数に格納する*/
						printf("%-10s %5.1f %5.1f\n", name, height, weight);
						ninzu++;
						hsum += height;
						wsum += weight;
					}		

		getchar
			1文字の入力を行う。入力の終了に達するか、エラーが発生するとEOFを返す。
				wthile ((ch = getchar()) != EOF) 		*/Hello*/
					putchar(ch);				*/Hello*/

			バッファリング
				getcharの入力は、１文字ずつ入力されるわけではなく、文字入力後にエンターが押された後に、まとめて出力が行わているが、これは環境に
				依存する。
					完全バッファリング
						バッファが満杯になったとき
					行バッファリング
						改行文字を読み込んだとき
					無バッファリング
						即座に読み書きが行われる

		fgetc
			標準ストリームではなく、streamが指すストリームから読み取る。第１引数にFILE *型になる以外はgetcharと同じ。
				while((ch = fgetc(fp)) != EOF)
					putchar(ch);

		fread
			第１引数には読み込むデータの先頭番地へのポインタ、第２引数にはデータの大きさ、第３引数にはデータの個数、第４引数には読み込み対象の
			ストリームへのポインタを受け取る。返却値は、書き込みに成功した要素の個数を返す。
				if ((fp = fopen("PI.bin", "wb")) == NULL)
					printf("\aファイルをオープンできません。\n");
				else{
					fread(&pi, seizeof(double), 1, fp);
						
		printf
			引数の値をコンソールに出力する。最初の実引数を書式文字列という。
				printf("15と37の和は%dです。\n",15+37);
				printf("%05.1f\n",123.45)				0123.4

			変換指定

				整数、浮動小数点

					%09.8f

					0フラグ(0)
						数値の前に余白があるときに、0をつめて表示する。省略された場合は、空白が詰められる。
							printf("[%05d]\n",	123);		/*[00123]
							printf("[%5d]\n",		123);		/*[  123]

					最小フィールド幅(9)
						最低限の表示文字数の指定。「-」が指定された場合は左側によせられて表示する。表示する数値がこの数値を超える桁数
						だった場合は、そのまま表示される。
							printf("[%3d]\n",		12345);	/*[12345]

					精度(8)
						表示する最小の小数値の桁数。省略されると、整数の精度は1とみなされ、浮動小数点の精度は6とみなされる。
							printf("[%f]\n",		123,13);	/*[123.130000]

					変換指定子(f)
						型を指定する。
							u	unsigned型
							o	8進数
							x	16進数
							p	アドレス

				文字列

					%s
						文字列(string型)を表示する。
					%3s
						３桁以上は表示する。
					%.3s
						３桁までしか表示しない。
					%8s
						８桁以上で右寄せ。
					%-8s
						８桁以上で左寄せ。

				%u	unsigned int,unsigned short。符号無し整数
				%ld	long。倍精度整数
				%lu	unsigned long。符号無し倍精度整数

		fprintf
			標準ストリームではなく、streamが指すストリームに書き込む。第１引数にFILE *型になる以外はprintfと同じ。つまり、画面に出力するのではなく
			ファイルに出力する。
				FILE *fp;
				if ((fp = fopen("dt_dat","w")) == NULL)
					printf("\aファイルをオープンできません。\n");
				else{
					printf("現在の日付・時刻をかき出しました。\n");
					fprintf(fp,"%d %d %d %d %d\n", 
						timer->tm_year + 1900, 	timer->tm_mon + 1, 	timer->tm_mday,
						timer->tm_hour,			timer->tm_min,		timer->tm_sec);
					fclose(fp);
				}

		puts
			printfと同じくコンソールに出力を行うが、改行が自動的に付き、書式設定や数値の出力などは不可能。

		putchar
			単一の文字表示を行う。
				putchar('\n');

			改行文字
				改行文字はprintfではなくputcharでの出力が推奨される。理由としては、文字列リテラルだとナル文字の分、記憶域を多く占有する。

		fputc
			標準ストリームではなく、streamが指すストリームかに書き込む。第１引数にFILE *型になる以外はputchar同じ。

		fwrite
			第１引数には書きこみするデータの先頭番地へのポインタ、第２引数にはデータの大きさ、第３引数にはデータの個数、第４引数には書き込み対象の
			ストリームへのポインタを受け取る。返却値は、書き込みに成功した要素の個数を返す。
				double pi = 3.1415923;
				fwite(&pi, seizeof(double), 1, fp);


	#include <ctype.h>

		toupper()
			英字を大文字に変換する。

		tolower()
			英字を小文字に変換する。


	#include <string.h>

		memset()		void *memset(void *s,int c,size_t n)
			記憶域（引数１のポインタ）の連続したバイト（引数３）に特定の値（引数２）を埋める。

		memcpy()		void *memcpy(void *s1,const void *s2,size_t n)
			引数２が指すオブジェクトの先頭n文字（引数３）を引数１が指すオブジェクトにコピーする。コピー元とコピー先が重なる場合の動作は定義されない。

		memmove()
			引数２が指すオブジェクトの先頭n文字（引数３）を引数１が指すオブジェクトにコピーする。コピー元とコピー先が重なる場合も正しくコピーする。

		memchr()		void *memchr(const void *s,int c,size_t n)
			s（引数１）が指すオブジェクトの先頭n文字（引数３）の中でunsigned char型に変換したcの最初の出現を探す。見つけた文字のポインタを
			返し、見つからなかった場合は、空ポインタを返す。途中にナル文字があっても走査が続くのがstrchrと違う。

		memcmp()		int memcmp(const void *s1,const void *s2,size_t n)
			s1（引数１）が指すオブジェクトの先頭n文字（引数３）と、s2（引数２）が指すオブジェクトの先頭n文字をunsigned char型の値として先頭から
			順に比較する。s1がs2より大きければ正の整数値、s1がs2より小さければ負の整数値を返す。
			途中にナル文字があっても走査が続くのがstrncmpと違う。

		strlen()
			文字列の長さを返す（ナル文字を含まない）。返却値型はsize_t型です。

		stycpy()
			文字列の引数２を引数１にコピーした値を返す。while (*s1++ = *s2++);形式で処理されるので、引数は配列の文字列のほうがいい。

		styncpy()
			基本的にはstycpy()と同じだが、引数３を指定することで、引数２を指定長さの文字列までコピーする。コピー先にナル文字が入っていなければ、ただの配列
			になる。

		strcat()
			文字列の引数２を引数１の末尾に連結して１つにして返す。

		strncat()
			基本的にはstrncat()と同じだが、引数３を指定することで、引数２を指定長さの文字列まで連結する。

		strchr()
			引数１の文字列から引数２の文字を探索し、先頭に見つかった文字へのポインタを返す。文字がなければ空ポインタを返す。

		strrchr()
			引数１の文字列から引数２の文字を探索し、先頭に見つかった文字へのポインタを返す。文字がなければ空ポインタを返す。
		
		strcmp()
			文字列の引数１と引数２を先頭から順に評価し、等しければ0、引数１の方が大きければ正の整数値、小さければ負の整数値を返す。

		strncmp()
			基本的にはstrncat()と同じだが、引数３を指定することで、引数２を指定長さの文字列まで判定を行う。

		strpbrk()
			引数１の文字列を順に走査し、引数２と一致した場合、引数１の一致した文字のポインタを返す。一致しなければ空ポインタを返す。

		strspn()
			引数２に含まれる文字だけで構成される部分が引数１の先頭に何文字あるかを調べる。

		strcspn()
			引数２に含まれない文字だけで構成される部分が引数１の先頭に何文字あるかを調べる。

		strstr()
			引数１から引数２と一致する文字列を探索する。見つかったら先頭文字のポインタを返し、見つからなかったら空ポインタを返す。

		strtok()
			引数２含まれる文字で引数１を分解する。２回以上呼び出すことで効果を発揮する特殊な関数。
			strtok(str,sep);
				１回目の呼び出し
					引数１の登録を行い、今後の呼び出しで分解する。ここでも、引数２の文字があれば、それにナル文字を書きかえる。
			strtok(NULL,sep);
				２回目以降の呼び出し
					引数１をナル文字にして呼び出す。前回ナル文字に書きかえた次の文字から走査される。
					



	#include <stdlib.h>

		atexit()
			正常なプログラム終了時に実引数無しで呼び出される関数として、引数の関数を登録する。登録できる関数の数は、処理系に依存するが少なくとも
			32個である。登録が成功すれば0、失敗すれば0以外の数値を返す。

		atoi()
			文字列の引数を整数型へと変換した値を返す。

		atol()
			文字列の引数をlong型へと変換した値を返す。

		atof()
			文字列の引数をdouble型へと変換した値を返す。

		calloc()		
			オブジェクト用の領域を動的に確保して、不要になったらfree関数で解放できる。引数１に個数、引数２に型の記憶域を指定して、ヒープと呼ばれる
			空き領域から記憶域を確保する。その領域は、ビットが0で初期化される。確保した領域の大きさを調べる手段はない。
			確保した領域のポインタを返し、その型は万能なポインタであるvoid *型で、どんな型にも代入できる。失敗した場合は空ポインタを返す。
				int *p;
				p = calloc(5,sizeof(int));

			使用するのは　確保した領域　+　範囲の情報
				確保した領域が先頭アドレスからどこまで領域であるかの情報が、確保した領域とは別の場所で消費されるので、小さな記憶域を数多く
				確保すると、無駄な記憶域を占有することになる。

			似非二次元配列のような形式の場合
				確保した領域の解放は注意深く、確実に行わなければならない。（明解C ポインタ編P224参照）

		malloc()		void *malloc(size_t size);
			callocと異なり引数が１つで、sizeバイトのオブジェクトの領域を確保する。初期化はされない。返却値は同じ。文字列の記憶域確保などで使われる。
				p = malloc(strlen(s) + 1);

		realloc()		void *realloc(void *ptr,size_t size);
			引数１が指すオブジェクト（記憶域）の大きさを引数２の大きさに変更する。先頭アドレスを返し、失敗したら空ポインタを返す。(空ポインタかどうかの確認する
			べき)確保した領域は以前と同じ位置にあるとは限らない。また、新たに確保した領域は0で埋められない。

				・引数１に空ポインタを与えると、malloc関数と同じ動作をする。
				・引数１に空ポインタでないポインタを与えて、引数２に0を与えるとfree関数と同じ動作をする。

		free()			void free(void *p);
			calloc関数などで確保された記憶域を解放する。引数がNULLであれば何も行わない。


	#include <time.h>

		time()
			現在の時刻を取得する。引数が指すオブジェクトにも値を格納するため、以下の記述方法がある。
				time(&current);
				current = time(NULL);
				current = time(&current);

			time_t型
				暦時刻と呼ばれる。long型やdouble型などの加減乗徐が可能な算術型で、どの型のの同義語となるかは処理系によって異なる。


		localtime()
			暦時刻の値を、地方時要素別の時刻に変換する。要はtime_t型の暦時刻をtm構造体に変換する。
				time_t current = time(NULL);
				struct tm *timer = localtime(&current);
				printf("現在の日時は%d年%d月%d日です。\n",
					timer->tm_year + 1900,				/*1900を加えて求める*/
					timer->tm_mon + 1,				/*1を加えて求める*/
					timer->tm_day,
				);

			tm構造体
				暦時刻time_t型は人間が直感的に理解できるものではないので、わかりやすく表現されたもの。

				struct tm{			/*一例であって、実際は処理系によってことなる*/
					int tm_sec;		/*秒(0～61)*/
					int tm_min;		/*分(0～59)*/
					int tm_hour;	/*時(0～23)*/
					int tm_mday;	/*日(1～31)*/
					int tm_mon;		/*1月からの月数(0～11)*/
					int tm_year;	/*1900年からの年数*/
					int tm_wday;	/*曜日：日曜～土曜(0～6)*/
					int tm_yday;	/*1月1日からの日数(0～365)*/
					int tm_isdst;	/*夏時間フラグ*/
				};


	#include <ctype.h>

		isprint()
			引数の文字列が空白' 'を含めた表示文字かどうかを判定する。



------------------------------------------------------------- アルゴリズム --------------------------------------------------------------


線形探索（逐次探索）

	配列の先頭から順に走査していき、目的とするものと同じ値をもつ要素をみつける一連の手続き。

番兵法

	線形探索などで、探索する値を配列の末尾に置き、値がみつからずに終わるのではなく、必ず見つかって終わるように工夫するやり方。

バブルソート

	１行目は隣通しを比較し、２行目は(要素数-1)個を同じように比較し、３行目は(要素数-2)子を比較し、…と全行走査すればソートされる。

		for(i = 0; i < n -1; i ++){
			for(j = n-1 ;j > i; j --){
				if (a[j -1] > a[j]{		/* ここの比較演算子を逆にすれば降順になる */
					int temp = a[j];
					a[j] = a[j -1];
					a[j -1] = temp;
				}
			}
		}


メニュードリブン

	選択したメニューに応じた選択的な処理を行うプログラム。




----------------------------------------------------------- ファイル処理 -----------------------------------------------------------



FILE型

	ストリームの制御に必要な情報を保存するための型。

		ストリーム　←　FILE型　←　FILE *型

	ファイル位置表示子
		現在アクセスしているアドレスを記録する。

	エラー表示子
		読み取りエラーまたは書き込みエラーが起こったかどうかを記録する。

	ファイル終了表示子
		ファイルの終わりに達したかどうかを記録する。


	FILE *型
		FILE型へのポインタ型

		標準ストリーム

			stdin
				標準入力ストリーム
					fscanf(stdin, "%d", &x);	/*scanfと同じ*/
			stdout
				標準出力ストリーム
					fprintf(stdout, "%d", x);	/*fprintfと同じ*/
			stderr
				標準エラーストリーム


ファイルのオープン

	fopen関数

		ファイル用にストリームを新設し、そのストリームを制御するための情報を格納しているFILE　*型を返す。返却値を変数に代入して使う。
			FILE *fp;
			fp = fopen("abc.txt","r");		/*返却値(fp)はストリームのポインタになる*/

		第２引数
			読み取りモード（ファイルからの入力だけを行う）
				r	テキストファイルを読み取りモードでオープンする。
				rb	バイナリファイルを読み取りモードでオープンする。

			書き込みモード（ファイルへの出力だけを行う）
				w	テキストファイルを書き込みモードで生成するか、または長さ0に切り捨てる。
				wb	バイナリファイルを書き込みモードで生成するか、または長さ0に切り捨てる。

			追加モード（ファイルの末尾位置以降への出力を行う）
				a	追加、すなわちテキストファイルをファイルの終わりの位置からの書き込みモードでオープンまたは生成する。
				ab	追加、すなわちバイナリファイルをファイルの終わりの位置からの書き込みモードでオープンまたは生成する。

			更新モード（ファイルに対する入出力を行う）
				r+	テキストファイルを更新（読み取りと書き込み）モードでオープンする。
				w+	テキストファイルを更新モードで生成するか、または長さ0に切り捨てる。
				a+	追加、すなわちテキストファイルをファイルの終わりの位置からの書き込みをする更新モードでオープンまたは生成する。

ファイルのクローズ

	fclose関数

		fopen関数が返したポインタをfclose関数に渡す。
			fclose(fp);


テキストファイルとバイナルファイル

	テキストファイル
		１つの文字を１バイトとして扱う。

		bit数		:数値の数と同じビット数が必要。
			3		5		7
			001110011	00110101	00110111

	バイナリファイル
		データをビットの並びで表現する。バイナリは二進数のこと。

		bit数		:処理系で決まったビット数で扱う。
			357
			0000000101100101


----------------------------------------------------------------- 用語 -----------------------------------------------------------------


識別子
	変数や関数などに与えられる名前。




----------------------------------------------------------- 環境構築 ------------------------------------------------------------


gccインストール
	7-Zip解凍ソフト →　mingw64

	mingw64		場所	:	C:/program files/mingw64
	環境変数設定

	確認			コマンドプロンプト　→　gcc -v

VScode
	C/C++インストール
	Code Runner
		拡張機能の設定
			Code-runner:Run In Terminal
			☑Whether to respect Shebang to run code.
		設定(JOIN)
			"code-runner.runInTerminal": true,
			"code-runner.executorMap": {複数記述}

			"[python]": {
       			 "editor.formatOnType": false
  			  },

	.vscode
		lanch.json
			"configurations": [
{
        "name": "g++.exe - Build and debug active file",
        "type": "cppdbg",
        "request": "launch",
        "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",
        "args": [],
        "stopAtEntry": false,
        "cwd": "${fileDirname}",
        "environment": [],
        "externalConsole": false,
        "MIMode": "gdb",
        "miDebuggerPath": "C:\\Program Files\\mingw64\\bin\\gdb.exe",
        "setupCommands": [
          {
            "description": "Enable pretty-printing for gdb",
            "text": "-enable-pretty-printing",
            "ignoreFailures": true
          }
        ],
        "preLaunchTask": "C/C++: gcc.exe アクティブなファイルのビルド"
      }

		]


		tasks.json
			"tasks": [
        {
            "type": "cppbuild",
            "label": "C/C++: gcc.exe アクティブなファイルのビルド",
            "command": "C:\\Program Files\\mingw64\\bin\\gcc.exe",
            "args": [
                "-fdiagnostics-color=always",
                "-g",
                "${file}",
                "-o",
                "${fileDirname}\\${fileBasenameNoExtension}.exe"
            ],
            "options": {
                "cwd": "${fileDirname}"
            },
            "problemMatcher": [
                "$gcc"
            ],
            "group": {
                "kind": "build",
                "isDefault": true
            },
            "detail": "デバッガーによって生成されたタスク。"
        }
    ],
    "version": "2.0.0"


		c_cpp_properties.json
			"configurations": [
        {
            "name": "Win32",
            "includePath": [
                "${workspaceFolder}/**"
            ],
            "defines": [
                "_DEBUG",
                "UNICODE",
                "_UNICODE"
            ],
            "compilerPath": "C:\\Program Files\\mingw64\\bin\\gcc.exe",
            "cStandard": "c17",
            "cppStandard": "gnu++14",
            "intelliSenseMode": "windows-gcc-x64"
        }
    ],
    "version": 4

gcc使い方

	cmd　→　cd ファイルのあるディレクトリ　→　gcc ファイル名　実行ファイルに名前を付ける時は(gcc -o 名前 ファイル名)
	→　作成されたファイル名を入力





----------------------------------------------------------- トラブル ------------------------------------------------------------


2023/03/21

	デバッグエラー
		「Unable to start debugging .Unexpected GDB output from command "-environment-cd パス」

	原因
		ファイルパスに日本語が含まれている。






